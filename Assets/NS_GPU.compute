// Each #kernel tells which function to compile; you can have many kernels

#pragma kernel navierStokes

// Create a RenderTexture with enableRandomWrite flag and set it
// with cs.SetTexture

float dt = 0.01f;

float visc = 0.1f;

float diffusion = 0.1f;

RWTexture2D<float> velXprev;
RWTexture2D<float> velYprev;

RWTexture2D<float> velXnext;
RWTexture2D<float> velYnext;

RWTexture2D<float> InputTex;
RWTexture2D<float> OutputTex;




uint maxWidth;
uint maxHeight;

groupshared float GSfloat[20*20*1];

void setBnd(int bound, RWTexture2D<float> boundTex, uint2 id)
    {
        RWTexture2D<float> temp = boundTex;

        if(bound == 2){
            temp[uint2(id.x, 0)] = -boundTex[uint2(id.x, 1)];
            temp[uint2(id.x, maxHeight)] = -boundTex[uint2(id.x, maxHeight-1)];
        }else{
            temp[uint2(id.x, 0)] = boundTex[uint2(id.x, 1)];
            temp[uint2(id.x, maxHeight)] = boundTex[uint2(id.x, maxHeight-1)];
        }

        if(bound == 1){
            temp[uint2(0, id.y)] = -boundTex[uint2(1, id.y)];
            temp[uint2(maxWidth, id.y)] = -boundTex[uint2(maxWidth-1, id.y)];
        }else{
            temp[uint2(0, id.y)] = boundTex[uint2(1, id.y)];
            temp[uint2(maxWidth, id.y)] = boundTex[uint2(maxWidth-1, id.y)];
        }

        if (id.x == 0 && id.y == 0){
            temp[uint2(0, 0)] = 0.5f * (boundTex[uint2(1, 0)] + boundTex[uint2(0, 1)]);
        }
        else if (id.x == 0 && id.y == maxHeight){
            temp[uint2(0, maxHeight)] = 0.5f * (boundTex[uint2(1, maxHeight)] + boundTex[uint2(0, maxHeight-1)]);
        }
        else if (id.x == maxWidth && id.y == 0){
            temp[uint2(maxWidth, 0)] = 0.5f * (boundTex[uint2(maxWidth-1, 0)] + boundTex[uint2(maxWidth, 1)]);
        }
        else if (id.x == maxWidth && id.y == maxHeight){
            temp[uint2(maxWidth, maxHeight)] = 0.5f * (boundTex[uint2(maxWidth-1, maxHeight)] + boundTex[uint2(maxWidth, maxHeight-1)]);
        }
        /*temp[uint2(0, 0)] = 0.5f * (boundTex[uint2(1, 0)] + boundTex[uint2(0, 1)]);
        temp[uint2(0, maxHeight)] = 0.5f * (boundTex[uint2(1, maxHeight)] + boundTex[uint2(0, maxHeight-1)]);
        temp[uint2(maxWidth, 0)] = 0.5f * (boundTex[uint2(maxWidth-1, 0)] + boundTex[uint2(maxWidth, 1)]);
        temp[uint2(maxWidth, maxHeight)] = 0.5f * (boundTex[uint2(maxWidth-1, maxHeight)] + boundTex[uint2(maxWidth, maxHeight-1)]);
        */
        boundTex[id] = temp[id];
    }

void linSolve(int bound, RWTexture2D<float> next, RWTexture2D<float> prev, float a, float c, uint2 id)
    {
        next[id] = (prev[id] + a * (next[id + uint2(1, 0)] + next[id + uint2(-1, 0)] + 
                    next[id + uint2(0, 1)] + next[id + uint2(0, -1)])) / c;

        setBnd(bound, next, id);
    }

void diffuse(int bound, RWTexture2D<float> next, RWTexture2D<float> prev, float spread, uint2 id){
    float a = dt * spread * (maxWidth - 1) * (maxHeight - 1);
    linSolve(bound, next, prev, a, 1 + 4 * a, id);
}

void advect(int bound, RWTexture2D<float> next, RWTexture2D<float> prev, RWTexture2D<float> velX, RWTexture2D<float> velY, uint2 id)
{    
    float x = id.x - dt * maxWidth-1 * velX[id.xy];
    float y = id.y - dt * maxHeight-1 * velY[id.xy];

    if(x < 0.5f) x = 0.5f;
    if(x > maxWidth-1 + 0.5f) x = maxWidth-1 + 0.5f;
    int i0 = (int)x;
    int i1 = i0 + 1;

    if(y < 0.5f) y = 0.5f;
    if(y > maxHeight-1 + 0.5f) y = maxHeight-1 + 0.5f;
    int j0 = (int)y;
    int j1 = j0 + 1;

    int s1 = (int)x - i0;
    int s0 = 1 - s1;
    int t1 = (int)y - j0;
    int t0 = 1 - t1;

    next[id.xy] = s0 * (t0 * prev[uint2(i0, j0)] + t1 * prev[uint2(i0, j1)]) +
                    s1 * (t0 * prev[uint2(i1, j0)] + t1 * prev[uint2(i1, j1)]);

        setBnd(bound, next, id);
    }

void project(RWTexture2D<float> velocX, RWTexture2D<float> velocY, RWTexture2D<float> p, RWTexture2D<float> div, uint2 id)
    {
        
        div[uint2(id.xy)] = -0.5f *
                    (velocX[uint2(id.x+1, id.y)] -
                      velocX[uint2(id.x-1, id.y)] +
                      velocY[uint2(id.x, id.y+1)] -
                      velocY[uint2(id.x, id.y-1)]) / ((maxWidth+1 + maxHeight+1)/2);
        
        p[uint2(id.xy)] = 0;

        setBnd(0, div, id);
        setBnd(0, p, id);
        linSolve(0, p, div, 1, 4, id);

        
        velocX[id.xy] -= 0.5f * (p[uint2(id.x+1, id.y)] - p[uint2(id.x-1, id.y)]) * (maxWidth+1);
        velocY[id.xy] -= 0.5f * (p[uint2(id.x, id.y+1)] - p[uint2(id.x, id.y-1)]) * (maxHeight+1);

        setBnd(1, velocX, id);
        setBnd(2, velocY, id);

    }

[numthreads(20,20,1)]
void navierStokes(uint2 id : SV_DispatchThreadID)
    {
        InputTex.GetDimensions(maxWidth, maxHeight);
        //mixing and spreading out. 1: left and right edge, 2: top and bottom edge
        diffuse(1, velXprev, velXnext, visc, id);
        diffuse(2, velYprev, velYnext, visc, id);

        //sets the boxes to equilibrium, has to be incompressible
        project(velXprev, velYprev, velXnext, velYnext, id);

        //moves dye from velocity. 1: left and right edge, 2: top and bottom edge
        advect(1, velXnext, velXprev, velXprev, velYprev, id);
        advect(2, velYnext, velYprev, velXprev, velYprev, id);

        //sets the boxes to equilibrium, has to be incompressible
        project(velXnext, velYnext, velXprev, velYprev, id);

        //mixing and spreading out. 0: not att edge
        diffuse(0, InputTex, OutputTex, diffusion, id);

        //moves dye from velocity. 0: not att edge
        advect(0, OutputTex, InputTex, velXnext, velYnext, id);

        // Swap the textures
        RWTexture2D<float> temp = velXprev;
        velXprev = velXnext;
        velXnext = temp;
        temp = velYprev;
        velYprev = velYnext;
        velYnext = temp;
    }
