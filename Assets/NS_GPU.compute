// Each #kernel tells which function to compile; you can have many kernels

#pragma kernel navierStokes

// Create a RenderTexture with enableRandomWrite flag and set it
// with cs.SetTexture

float dt = 0.01f;

float visc = 0.01f;

float diffusion = 0.01f;

RWTexture2D<float> velXprev;
RWTexture2D<float> velYprev;

RWTexture2D<float> velXnext;
RWTexture2D<float> velYnext;

RWTexture2D<float> InputTex;
RWTexture2D<float> OutputTex;

uint maxWidth;
uint maxHeight;

void setBnd(int bound, RWTexture2D<float> boundTex, uint2 id)
    {

        RWTexture2D<float> temp = boundTex;

        /*if(bound == 2){
            if(id.y == 0){
                temp[uint2(id.x, 0)] = -boundTex[uint2(id.x, 1)];
            }
            else if(id.y == maxHeight){
                temp[uint2(id.x, maxHeight-1)] = -boundTex[uint2(id.x, maxHeight-2)];
            }
        }else{
            if(id.y == 0){
                temp[uint2(id.x, 0)] = boundTex[uint2(id.x, 1)];
            }
            else if(id.y == maxHeight-1){
                temp[uint2(id.x, maxHeight-1)] = boundTex[uint2(id.x, maxHeight-2)];
            }
        }

        if(bound == 1){
            if(id.x == 0){
                temp[uint2(0, id.y)] = -boundTex[uint2(1, id.y)];
            }
            else if(id.x == maxWidth-1){
                temp[uint2(maxWidth-1, id.y)] = -boundTex[uint2(maxWidth-2, id.y)];
            }
        }else{
            if(id.x == 0){
                temp[uint2(0, id.y)] = boundTex[uint2(1, id.y)];
            }
            else if(id.x == maxWidth-1){
                temp[uint2(maxWidth-1, id.y)] = boundTex[uint2(maxWidth-2, id.y)];
            }
        }

        if (id.x == 0 && id.y == 0){
            temp[uint2(0, 0)] = 0.5f * (boundTex[uint2(1, 0)] + boundTex[uint2(0, 1)]);
        }
        else if (id.x == 0 && id.y == maxHeight-1){
            temp[uint2(0, maxHeight-1)] = 0.5f * (boundTex[uint2(1, maxHeight-1)] + boundTex[uint2(0, maxHeight-2)]);
        }
        else if (id.x == maxWidth-1 && id.y == 0){
            temp[uint2(maxWidth-1, 0)] = 0.5f * (boundTex[uint2(maxWidth-2, 0)] + boundTex[uint2(maxWidth-1, 1)]);
        }
        else if (id.x == maxWidth-1 && id.y == maxHeight-1){
            temp[uint2(maxWidth-1, maxHeight-1)] = 0.5f * (boundTex[uint2(maxWidth-2, maxHeight-1)] + boundTex[uint2(maxWidth-1, maxHeight-2)]);
        }*/

        if(id.x == 0){
            temp[uint2(0, id.y)] = 0.0f;
        }
        else if(id.x == maxWidth-1){
            temp[uint2(maxWidth-1, id.y)] = 0.0f;
        }
        if(id.y == 0){
            temp[uint2(id.x, 0)] = 0.0f;
        }
        else if(id.y == maxHeight-1){
            temp[uint2(id.x, maxHeight-1)] = 0.0f;
        }
        boundTex[id] = temp[id];

    }


void linSolve(int bound, RWTexture2D<float> next, RWTexture2D<float> prev, float a, float c, uint2 id)
    {
        next[id] = (prev[id] + a * (next[id + uint2(1, 0)] + next[id + uint2(-1, 0)] + 
                    next[id + uint2(0, 1)] + next[id + uint2(0, -1)])) / c;

        setBnd(bound, next, id);
    }

void diffuse(int bound, RWTexture2D<float> next, RWTexture2D<float> prev, float spread, uint2 id){
    float a = dt * spread * (maxWidth - 2) * (maxHeight - 2);
    linSolve(bound, next, prev, a, 1 + 4 * a, id);
}

void advect(int bound, RWTexture2D<float> next, RWTexture2D<float> prev, RWTexture2D<float> velX, RWTexture2D<float> velY, uint2 id)
{    
    /*float x = id.x - dt * maxWidth-1 * velX[id.xy];
    float y = id.y - dt * maxHeight-1 * velY[id.xy];

    if(x < 0.5f) x = 0.5f;
    if(x > maxWidth-1 + 0.5f) x = maxWidth-1 + 0.5f;
    int i0 = (int)x;
    int i1 = i0 + 1;

    if(y < 0.5f) y = 0.5f;
    if(y > maxHeight-1 + 0.5f) y = maxHeight-1 + 0.5f;
    int j0 = (int)y;
    int j1 = j0 + 1;

    int s1 = (int)x - i0;
    int s0 = 1 - s1;
    int t1 = (int)y - j0;
    int t0 = 1 - t1;

    next[id.xy] = s0 * (t0 * prev[uint2(i0, j0)] + t1 * prev[uint2(i0, j1)]) +
                    s1 * (t0 * prev[uint2(i1, j0)] + t1 * prev[uint2(i1, j1)]);
*/
    //if (any(id >= _Resolution))
	//	return;

	/*float2 dt0 = dt * (float2(maxWidth, maxHeight) - 2);
	float2 vec = float2(id) - dt0 * float2(velX[id], velY[id]);
	vec = clamp(vec, 0.5, (float2(maxWidth, maxHeight) - 2) + 0.5);*/
    
	float2 dt0 = dt * (float2(maxWidth-2.0f, maxHeight-2.0f));
	float2 vec = float2(id) - dt0 * float2(velX[id], velY[id]);
	vec = clamp(vec, 0.5, (float2(maxWidth-2.0f, maxHeight-2.0f)) + 0.5);

	uint2 xy0 = (uint2) vec;
	uint2 xy1 = xy0 + 1;

	float2 st1 = vec - xy0;
	float2 st0 = 1 - st1;

	next[id] = 
		st0.x * (st0.y * prev[xy0] +
			     st1.y * prev[uint2(xy0.x, xy1.y)]) +
		st1.x * (st0.y * prev[uint2(xy1.x, xy0.y)] +
			     st1.y * prev[xy1]);

        setBnd(bound, next, id);
    }

void project(RWTexture2D<float> velocX, RWTexture2D<float> velocY, RWTexture2D<float> pressure, RWTexture2D<float> divergence, uint2 id)
    {
        
        divergence[uint2(id.xy)] = -0.5f *
                    (velocX[uint2(id.x+1, id.y)] -
                      velocX[uint2(id.x-1, id.y)] +
                      velocY[uint2(id.x, id.y+1)] -
                      velocY[uint2(id.x, id.y-1)]) / ((maxWidth + maxHeight)/2.0f);
        
        pressure[uint2(id.xy)] = 0;

        setBnd(0, divergence, id);
        setBnd(0, pressure, id);
        linSolve(0, pressure, divergence, 1, 4, id);

        
        velocX[id.xy] -= 0.5f * (pressure[uint2(id.x+1, id.y)] - pressure[uint2(id.x-1, id.y)]) * (maxWidth);
        velocY[id.xy] -= 0.5f * (pressure[uint2(id.x, id.y+1)] - pressure[uint2(id.x, id.y-1)]) * (maxHeight);

        setBnd(1, velocX, id);
        setBnd(2, velocY, id);

    }

[numthreads(20,20,1)]
void navierStokes(uint2 id : SV_DispatchThreadID)
    {
        //InputTex.GetDimensions(maxWidth, maxHeight);
        maxWidth = 20;
        maxHeight = 20;
        //mixing and spreading out. 1: left and right edge, 2: top and bottom edge
        diffuse(1, velXprev, velXnext, visc, id);
        diffuse(2, velYprev, velYnext, visc, id);

        //sets the boxes to equilibrium, has to be incompressible
        project(velXprev, velYprev, velXnext, velYnext, id);

        //moves dye from velocity. 1: left and right edge, 2: top and bottom edge
        advect(1, velXnext, velXprev, velXprev, velYprev, id);
        advect(2, velYnext, velYprev, velXprev, velYprev, id);

        //sets the boxes to equilibrium, has to be incompressible
        project(velXnext, velYnext, velXprev, velYprev, id);
    
        //mixing and spreading out. 0: not at edge
        diffuse(0, InputTex, OutputTex, diffusion, id);

        //moves dye from velocity. 0: not at edge
        advect(0, OutputTex, InputTex, velXnext, velYnext, id);
        // Swap the textures
        /*velXprev = velXnext;
        velYprev = velYnext;
        InputTex = OutputTex;*/
    }
