// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel Density
#pragma kernel Collision
#pragma kernel Streaming
#pragma kernel AddValue
#pragma kernel AddVelocity
#pragma kernel HandleBoundaries
#pragma kernel Setup
#pragma kernel Out

// Create a RenderTexture with enableRandomWrite flag and set it
// with cs.SetTexture
RWTexture3D<float> fTexture;
RWTexture3D<float> fnewTexture;
RWTexture3D<float> feqTexture;
RWTexture2D<float> rhoTexture;
RWTexture2D<float> inRhoTexture;
RWTexture2D<float2> velTexture;
RWTexture2D<float> latticeTexture;
RWTexture2D<float> outTexture;

#define tau 1.50f

float hitPosX;
float hitPosY;

float xAmount;
float yAmount;

uint width;
uint height;

[numthreads(8, 8, 1)]
void Density(uint2 id : SV_DispatchThreadID)
{
    float rhoTmp = 0.0f;
    float mXTmp = 0.0f;
    float mYTmp = 0.0f;

    for (int k = 0; k < 9; k++) 
    {
        rhoTmp += fTexture[uint3(id.x, id.y, k)];
        mXTmp += fTexture[uint3(id.x, id.y, k)] * latticeTexture[uint2(k, 0)];    
        mYTmp += fTexture[uint3(id.x, id.y, k)] * latticeTexture[uint2(k, 1)];
    }

    rhoTmp += inRhoTexture[id];

    if (rhoTmp < 0.01f) 
    {       
        velTexture[id] = float2(mXTmp / 0.01f, mYTmp / 0.01f);
    }
    else
    {
        velTexture[id] = float2(mXTmp / rhoTmp, mYTmp / rhoTmp);
    }
    
    float distance = sqrt(velTexture[id].x * velTexture[id].x + velTexture[id].y * velTexture[id].y);
                

    if(distance > 1.0f)
    {
        velTexture[id] = float2(velTexture[id].x / (distance), velTexture[id].y / (distance));
    }
    velTexture[id] = float2(velTexture[id].x / 1.50f, velTexture[id].y / 1.50f);
    rhoTexture[id] = rhoTmp;
    inRhoTexture[id] = 0.0f;
    //inRhoTexture[id] = latticeTexture[uint2(0,1)]*10.0f;
}

[numthreads(8, 8, 1)]
void Collision(uint2 id : SV_DispatchThreadID)
{
    //lattice speed c=1
    //soundspeed squared = 1/3
    for (int k = 0; k < 9; k++) 
    {
        float vu = latticeTexture[uint2(k, 0)] * velTexture[id].x + latticeTexture[uint2(k, 1)] * velTexture[id].y;
        float uu = velTexture[id].x * velTexture[id].x + velTexture[id].y * velTexture[id].y;
        
        feqTexture[uint3(id.x, id.y, k)] = latticeTexture[uint2(k, 2)] * rhoTexture[id] * (1.0f + 3.0f * vu + (9.0f / 2.0f) * vu * vu + (3.0f / 2.0f) * uu);
        fnewTexture[uint3(id.x, id.y, k)] = fTexture[uint3(id.x, id.y, k)] - (fTexture[uint3(id.x, id.y, k)] - feqTexture[uint3(id.x, id.y, k)]) / tau;
    }
}

[numthreads(8, 8, 1)]
void Streaming(uint2 id : SV_DispatchThreadID)
{
    for (int k = 0; k < 9; ++k)
    {
        int nextX = (id.x + latticeTexture[uint2(k, 0)]);
        int nextY = (id.y + latticeTexture[uint2(k, 1)]);

        
        if(id.x == 0)
        {
            if (nextX < 0)
            {
                fTexture[uint3(id.x, id.y, k)] = fnewTexture[uint3(id.x, id.y, k+2)];
            }
        }   
        else if(id.x == width-1)
        {
            if (nextX >= width)
            {
                fTexture[uint3(id.x, id.y, k)] = fnewTexture[uint3(id.x, id.y, -2)];
            }
        }
        else if(id.y == 0)
        {
            if (nextY < 0)
            {
                fTexture[uint3(id.x, id.y, k)] = fnewTexture[uint3(id.x, id.y, k+6)];
            }
        }
        else if(id.y == height-1)
        {
            if (nextY >= height)
            {
                fTexture[uint3(id.x, id.y, k)] = fnewTexture[uint3(id.x, id.y, k-6)];
            }
        }
        else
        {
            fTexture[uint3(nextX, nextY, k)] = fnewTexture[uint3(id.x, id.y, k)];
        }
    }
}        
//NW N NE E SE S SW W C 
[numthreads(8, 8, 1)]
void HandleBoundaries(uint2 id : SV_DispatchThreadID)
{
    for (int k = 0; k < 9; ++k)
    {
        int nextX = (id.x + latticeTexture[uint2(k, 0)]);
        int nextY = (id.y + latticeTexture[uint2(k, 1)]);

        
        if(id.x == 0)
        {
            if (nextX < 0)
            {
                fTexture[uint3(id.x, id.y, k)] = fnewTexture[uint3(id.x, id.y, k+2)];
            }
        }   
        else if(id.x == width-1)
        {
            if (nextX >= width)
            {
                fTexture[uint3(id.x, id.y, k)] = fnewTexture[uint3(id.x, id.y, -2)];
            }
        }
        else if(id.y == 0)
        {
            if (nextY < 0)
            {
                fTexture[uint3(id.x, id.y, k)] = fnewTexture[uint3(id.x, id.y, k+6)];
            }
        }
        else if(id.y == height-1)
        {
            if (nextY >= height)
            {
                fTexture[uint3(id.x, id.y, k)] = fnewTexture[uint3(id.x, id.y, k-6)];
            }
        }
        else
        {
            fTexture[uint3(nextX, nextY, k)] = fnewTexture[uint3(id.x, id.y, k)];
        }
    }
}

[numthreads(1, 1, 1)]
void AddValue(uint2 id : SV_DispatchThreadID)
{
	inRhoTexture[uint2(hitPosX, hitPosY)] += 10.0f;
}

[numthreads(1, 1, 1)]
void AddVelocity(uint2 id : SV_DispatchThreadID)
{
    float2 newVelocity;
    newVelocity.x = xAmount * width * 10;
    newVelocity.y = yAmount * height * 10;
	velTexture[uint2(hitPosX, hitPosY)] += newVelocity;
}

[numthreads(8, 8, 1)]
void Setup(uint2 id : SV_DispatchThreadID)
{
    rhoTexture[id] = 1.0f;
}

[numthreads(8, 8, 1)]
void Out(uint2 id : SV_DispatchThreadID)
{
    outTexture[id] = rhoTexture[id]-1.0f;
}