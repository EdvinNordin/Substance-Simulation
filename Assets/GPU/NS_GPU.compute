// FluidSimulation.compute

#pragma kernel Diffusion
#pragma kernel Advection
#pragma kernel Projection1
#pragma kernel Projection2
#pragma kernel Projection3
#pragma kernel SetBounds
#pragma kernel TextureSet
#pragma kernel AddValue
#pragma kernel AddVelocity

uint Width;
uint Height;

int indicator;
int value;
int velocity;

float dt;
float spread;
float hitPosX;
float hitPosY;
float xAmount;
float yAmount;


Texture2D<float4> _In;  // Input Texture
RWTexture2D<float4> _Out;  // Output Texture
RWTexture2D<float4> _Temp;  // Velocity Texture

[numthreads(8, 8, 1)]
void Diffusion(int2 id : SV_DispatchThreadID)
{
    float a = dt * spread * (Width - 2) * (Height - 2);
   
	if (indicator == 0){
        _Temp[id] = float4(
        (_In[id].r + a * (_Out[id + int2(1, 0)].r + _Out[id + int2(-1, 0)].r + 
        _Out[id + int2(0, 1)].r + _Out[id + int2(0, -1)].r)) / (1 + 4 * a), _Out[id].gba);
	}
	else if (indicator == 1){
        _Temp[id] = float4(_Out[id].r,
			(_In[id].g + a * (_Out[id + int2(1, 0)].g + _Out[id + int2(-1, 0)].g + 
			_Out[id + int2(0, 1)].g + _Out[id + int2(0, -1)].g)) / (1 + 4 * a), _Out[id].ba);
	}
	else if (indicator == 2){
        _Temp[id] = float4(_Out[id].rg,
			(_In[id].b + a * (_Out[id + int2(1, 0)].b + _Out[id + int2(-1, 0)].b + 
			_Out[id + int2(0, 1)].b + _Out[id + int2(0, -1)].b)) / (1 + 4 * a), _Out[id].a);
	}
}

[numthreads(8, 8, 1)]
void Advection(int2 id : SV_DispatchThreadID)
{

    //backwards trace the velocity field
    float2 dtScaled = dt * (float2(Width-2.0f, Height-2.0f)); //scaled dt by texture size
	float2 backtrace = float2(id) - dtScaled * float2(_In[id].g, _In[id].b); //traced position backwards in time
	//float2 backtrace = float2(id) - dtScaled * float2(_Out[id].y, _Out[id].z);
	backtrace = clamp(backtrace, 0.5, (float2(Width-2.0f, Height-2.0f)) + 0.5); //clamp the traced position to the texture size

	int2 backtraceInt = (int2) backtrace; //get the integer part of the traced position
	int2 backtraceIntNext = backtraceInt + 1; //get the next integer part of the traced position

	float2 weightNE = backtrace - backtraceInt; //get the north east weight of the traced position which is the fractional part of the traced position
	float2 weightSW = 1 - weightNE; //get the south west weight of the traced position which is 1 - the fractional part of the traced position

    //interpolate the traced position using the weights and the values of the traced position and the next position
    if(indicator == 0){
		_Out[id] = float4(
            weightSW.x * (weightSW.y * _In[backtraceInt].r + weightNE.y * _In[int2(backtraceInt.x, backtraceIntNext.y)].r) +
		    weightNE.x * (weightSW.y * _In[int2(backtraceIntNext.x, backtraceInt.y)].r + weightNE.y * _In[backtraceIntNext].r), 
            _Out[id].gba);
	}
	else if (indicator == 1)
	{
		_Out[id] = float4(_Out[id].r, 
            weightSW.x * (weightSW.y * _In[backtraceInt].r + weightNE.y * _In[int2(backtraceInt.x, backtraceIntNext.y)].r) +
		    weightNE.x * (weightSW.y * _In[int2(backtraceIntNext.x, backtraceInt.y)].r + weightNE.y * _In[backtraceIntNext].r), 
            _Out[id].ba);
	}
    else if (indicator == 2)
	{
		_Out[id] = float4(_Out[id].rg, 
            weightSW.x * (weightSW.y * _In[backtraceInt].r + weightNE.y * _In[int2(backtraceInt.x, backtraceIntNext.y)].r) +
		    weightNE.x * (weightSW.y * _In[int2(backtraceIntNext.x, backtraceInt.y)].r + weightNE.y * _In[backtraceIntNext].r), 
            _Out[id].a);
	}
}

[numthreads(8, 8, 1)]
void Projection1(int2 id : SV_DispatchThreadID) 
{
	//Out.y = pressure = 0
    //Out.z = divergence =>
    _Temp[id] = float4(_Out[id].r, 0, -0.5f *
                    ((_In[int2(id.x+1, id.y)].g -
                      _In[int2(id.x-1, id.y)].g)/Width +
                      (_In[int2(id.x, id.y+1)].b -
                      _In[int2(id.x, id.y-1)].b)/ 
                      Height), _Out[id].a);
}

[numthreads(8, 8, 1)]
void Projection2(int2 id : SV_DispatchThreadID) 
{
    _Temp[id] = float4(_Out[id].r,
                (_Out[id].b + (_Out[int2(id.x+1, id.y)].g + _Out[int2(id.x-1, id.y)].g + 
                _Out[int2(id.x, id.y+1)].g + _Out[int2(id.x, id.y-1)].g)) / 4 , _Out[id].ba);
}

[numthreads(8, 8, 1)]
void Projection3(int2 id : SV_DispatchThreadID) 
{
    _Temp[id] = float4(_Out[id].r, 
					_In[id].g - 0.5f * (_Out[int2(id.x+1, id.y)].g - _Out[int2(id.x-1, id.y)].g) * (Width),
    				_In[id].b - 0.5f * (_Out[int2(id.x, id.y+1)].g - _Out[int2(id.x, id.y-1)].g) * (Height), 
					_Out[id].z);
}

[numthreads(8, 8, 1)]
void SetBounds(int2 id : SV_DispatchThreadID)
{
    if(id.x < Width && id.y == 0){ //bottom
        if(_In[int2(id.x, 0)].b < 0){ //if velocity is downwards
            _Out[int2(id.x, 0)] = float4(_Out[int2(id.x, 0)].rg, -_In[int2(id.x, 0)].b, _Out[int2(id.x, 0)].a);
        }
    }
    else if(id.x < Width && id.y == Height-1){ //top
        if(_In[int2(id.x, Height-1)].b > 0){ //if velocity is upwards
            _Out[int2(id.x, Height-1)] = float4(_Out[int2(id.x, Height-1)].rg, -_In[int2(id.x, Height-1)].b, _Out[int2(id.x, Height-1)].a);
        }
    }

    if(id.x == 0 && id.y < Height){ //left
        if(_In[int2(0, id.y)].g < 0){ //if velocity is left
            _Out[int2(0, id.y)] = float4(_Out[int2(0, id.y)].r, -_In[int2(0, id.y)].g, _Out[int2(0, id.y)].ba);
        }
    }
    else if(id.x == Width-1 && id.y < Height){ //right
        if(_In[int2(Width-1, id.y)].y > 0){ //if velocity is right
            _Out[int2(Width-1, id.y)] = float4(_Out[int2(Width-1, id.y)].r, -_In[int2(Width-1, id.y)].g, _Out[int2(Width-1, id.y)].ba);
        }
    }   
}

[numthreads(8, 8, 1)]
void TextureSet(int2 id : SV_DispatchThreadID)
{
    _Out[id] = float4(_In[id]);
}

[numthreads(1, 1, 1)]
void AddValue(int2 id : SV_DispatchThreadID)
{
	_Out[int2(hitPosX, hitPosY)] = float4(_Out[int2(hitPosX, hitPosY)].r + value, _Out[int2(hitPosX, hitPosY)].gba);
}

[numthreads(1, 1, 1)]
void AddVelocity(int2 id : SV_DispatchThreadID)
{
    _Out[int2(hitPosX, hitPosY)] = float4(_Out[int2(hitPosX, hitPosY)].r, _Out[int2(hitPosX, hitPosY)].g + velocity, _Out[int2(hitPosX, hitPosY)].b + velocity, _Out[int2(hitPosX, hitPosY)].a);
}